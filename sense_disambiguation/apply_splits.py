#!/usr/bin/env python3
"""
Apply Split Proposals to Hierarchy Files

This script reads the split proposals generated by the sense disambiguation system
and applies the accepted splits to create updated hierarchy files.

Usage:
    python apply_splits.py --split-results-dir <path> --hierarchy-file <path> --output-dir <path>
"""

import json
import os
import argparse
import shutil
from datetime import datetime
from typing import Dict, List, Any, Set
import logging

def setup_logging():
    """Setup logging configuration."""
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(message)s'
    )
    return logging.getLogger(__name__)

logger = setup_logging()

def load_split_proposals(split_results_dir: str) -> Dict[int, Dict[str, Any]]:
    """
    Load split proposals from all levels.
    
    Args:
        split_results_dir: Directory containing split proposal files
        
    Returns:
        Dictionary mapping level to split proposals data
    """
    proposals_by_level = {}
    
    for level in range(4):  # Levels 0-3
        filename = f"split_proposals_level{level}.json"
        filepath = os.path.join(split_results_dir, filename)
        
        if os.path.exists(filepath):
            logger.info(f"Loading split proposals for level {level}")
            with open(filepath, 'r') as f:
                data = json.load(f)
                proposals_by_level[level] = data
        else:
            logger.warning(f"Split proposals file not found: {filepath}")
    
    return proposals_by_level

def load_hierarchy(hierarchy_file: str) -> Dict[str, Any]:
    """
    Load the hierarchy file.
    
    Args:
        hierarchy_file: Path to the hierarchy.json file
        
    Returns:
        Hierarchy data as dictionary
    """
    logger.info(f"Loading hierarchy from {hierarchy_file}")
    with open(hierarchy_file, 'r') as f:
        return json.load(f)

def extract_accepted_splits(proposals_by_level: Dict[int, Dict[str, Any]]) -> Dict[str, List[Dict[str, Any]]]:
    """
    Extract all accepted split proposals organized by original term.
    
    Args:
        proposals_by_level: Split proposals data by level
        
    Returns:
        Dictionary mapping original term to list of accepted split proposals
    """
    splits_by_term = {}
    
    for level, data in proposals_by_level.items():
        accepted_proposals = data.get('accepted_proposals', [])
        logger.info(f"Level {level}: Found {len(accepted_proposals)} accepted split proposals")
        
        for proposal in accepted_proposals:
            original_term = proposal['original_term']
            if original_term not in splits_by_term:
                splits_by_term[original_term] = []
            splits_by_term[original_term].append(proposal)
    
    logger.info(f"Total unique terms to split: {len(splits_by_term)}")
    return splits_by_term

def apply_term_split(hierarchy: Dict[str, Any], original_term: str, proposal: Dict[str, Any]) -> Dict[str, Any]:
    """
    Apply a single term split to the hierarchy.
    
    Args:
        hierarchy: The hierarchy data
        original_term: The term to split
        proposal: The split proposal data
        
    Returns:
        Updated hierarchy data
    """
    terms = hierarchy.get('terms', {})
    
    if original_term not in terms:
        logger.warning(f"Term '{original_term}' not found in hierarchy")
        return hierarchy
    
    original_term_data = terms[original_term]
    level = proposal.get('level', original_term_data.get('level', 0))
    
    logger.info(f"Splitting term '{original_term}' at level {level} into {len(proposal['proposed_senses'])} senses")
    
    # Remove the original term
    del terms[original_term]
    
    # Create new terms for each sense
    for sense_info in proposal['proposed_senses']:
        sense_tag = sense_info['sense_tag']
        
        # Create display tag by removing underscores for better readability
        display_tag = sense_tag.replace('_', ' ')
        
        # Create new term name by combining original term with display tag
        new_term_name = f"{original_term} ({display_tag})"
        
        # Create new term data based on the original term
        new_term_data = original_term_data.copy()
        
        # Update the term name and add disambiguation info
        new_term_data['original_term'] = original_term
        new_term_data['sense_tag'] = sense_tag  # Keep original tag with underscores in metadata
        new_term_data['display_tag'] = display_tag  # Add readable display tag
        new_term_data['split_info'] = {
            'cluster_id': sense_info['cluster_id'],
            'resource_count': sense_info['resource_count'],
            'split_reason': proposal.get('split_reason', ''),
            'split_timestamp': datetime.now().isoformat()
        }
        
        # If we have sample resources from the split, we could potentially
        # distribute the original resources, but for now we'll keep all resources
        # in each sense since the clustering was based on content analysis
        
        # Add the new term to the hierarchy
        terms[new_term_name] = new_term_data
        
        logger.info(f"Created new term: '{new_term_name}' with sense tag '{sense_tag}' (display: '{display_tag}')")
    
    return hierarchy

def apply_all_splits(hierarchy: Dict[str, Any], splits_by_term: Dict[str, List[Dict[str, Any]]]) -> Dict[str, Any]:
    """
    Apply all splits to the hierarchy.
    
    Args:
        hierarchy: The hierarchy data
        splits_by_term: Dictionary of splits organized by term
        
    Returns:
        Updated hierarchy data
    """
    updated_hierarchy = hierarchy.copy()
    
    # Track statistics
    total_splits = 0
    total_new_terms = 0
    
    for original_term, proposals in splits_by_term.items():
        logger.info(f"Processing splits for term: '{original_term}'")
        
        # For now, apply only the first proposal if multiple exist
        # (This shouldn't happen in normal cases, but could occur if
        # the same term was split at multiple levels)
        if len(proposals) > 1:
            logger.warning(f"Multiple split proposals found for '{original_term}'. Using the first one.")
        
        proposal = proposals[0]
        updated_hierarchy = apply_term_split(updated_hierarchy, original_term, proposal)
        
        total_splits += 1
        total_new_terms += len(proposal['proposed_senses'])
    
    logger.info(f"Applied {total_splits} splits, creating {total_new_terms} new terms")
    
    # Update metadata
    if 'metadata' not in updated_hierarchy:
        updated_hierarchy['metadata'] = {}
    
    updated_hierarchy['metadata']['split_application'] = {
        'timestamp': datetime.now().isoformat(),
        'splits_applied': total_splits,
        'new_terms_created': total_new_terms,
        'original_terms_removed': total_splits
    }
    
    return updated_hierarchy

def save_updated_hierarchy(hierarchy: Dict[str, Any], output_file: str):
    """
    Save the updated hierarchy to a file.
    
    Args:
        hierarchy: The updated hierarchy data
        output_file: Path to save the updated hierarchy
    """
    logger.info(f"Saving updated hierarchy to {output_file}")
    
    # Create output directory if it doesn't exist
    output_dir = os.path.dirname(output_file)
    if output_dir:
        os.makedirs(output_dir, exist_ok=True)
    
    with open(output_file, 'w') as f:
        json.dump(hierarchy, f, indent=2, ensure_ascii=False)
    
    logger.info(f"Successfully saved updated hierarchy")

def create_split_summary(splits_by_term: Dict[str, List[Dict[str, Any]]], output_dir: str):
    """
    Create a summary of all applied splits.
    
    Args:
        splits_by_term: Dictionary of splits organized by term
        output_dir: Directory to save the summary
    """
    summary_file = os.path.join(output_dir, 'split_summary.json')
    
    summary = {
        'timestamp': datetime.now().isoformat(),
        'total_terms_split': len(splits_by_term),
        'splits_by_level': {},
        'detailed_splits': []
    }
    
    # Count splits by level
    level_counts = {}
    
    for original_term, proposals in splits_by_term.items():
        proposal = proposals[0]  # Use first proposal
        level = proposal.get('level', 0)
        
        if level not in level_counts:
            level_counts[level] = 0
        level_counts[level] += 1
        
        # Create detailed split info
        split_detail = {
            'original_term': original_term,
            'level': level,
            'new_terms': [],
            'split_reason': proposal.get('split_reason', '')
        }
        
        for sense_info in proposal['proposed_senses']:
            sense_tag = sense_info['sense_tag']
            display_tag = sense_tag.replace('_', ' ')  # Remove underscores for display
            new_term_name = f"{original_term} ({display_tag})"
            split_detail['new_terms'].append({
                'term': new_term_name,
                'sense_tag': sense_tag,  # Keep original tag with underscores for reference
                'display_tag': display_tag,  # Add readable display tag
                'resource_count': sense_info['resource_count']
            })
        
        summary['detailed_splits'].append(split_detail)
    
    summary['splits_by_level'] = level_counts
    
    with open(summary_file, 'w') as f:
        json.dump(summary, f, indent=2, ensure_ascii=False)
    
    logger.info(f"Split summary saved to {summary_file}")

def main():
    parser = argparse.ArgumentParser(description='Apply split proposals to hierarchy files')
    parser.add_argument('--split-results-dir', required=True,
                        help='Directory containing split proposal files')
    parser.add_argument('--hierarchy-file', required=True,
                        help='Path to the original hierarchy.json file')
    parser.add_argument('--output-dir', required=True,
                        help='Directory to save updated files')
    parser.add_argument('--backup', action='store_true',
                        help='Create backup of original hierarchy file')
    
    args = parser.parse_args()
    
    # Validate input paths
    if not os.path.exists(args.split_results_dir):
        logger.error(f"Split results directory not found: {args.split_results_dir}")
        return 1
    
    if not os.path.exists(args.hierarchy_file):
        logger.error(f"Hierarchy file not found: {args.hierarchy_file}")
        return 1
    
    # Create output directory
    os.makedirs(args.output_dir, exist_ok=True)
    
    # Create backup if requested
    if args.backup:
        backup_file = os.path.join(args.output_dir, 'hierarchy_backup.json')
        shutil.copy2(args.hierarchy_file, backup_file)
        logger.info(f"Created backup: {backup_file}")
    
    try:
        # Load split proposals
        proposals_by_level = load_split_proposals(args.split_results_dir)
        
        if not proposals_by_level:
            logger.error("No split proposals found")
            return 1
        
        # Extract accepted splits
        splits_by_term = extract_accepted_splits(proposals_by_level)
        
        if not splits_by_term:
            logger.info("No accepted splits found - nothing to apply")
            return 0
        
        # Load original hierarchy
        hierarchy = load_hierarchy(args.hierarchy_file)
        
        # Apply splits
        updated_hierarchy = apply_all_splits(hierarchy, splits_by_term)
        
        # Save updated hierarchy
        output_hierarchy_file = os.path.join(args.output_dir, 'hierarchy_with_splits.json')
        save_updated_hierarchy(updated_hierarchy, output_hierarchy_file)
        
        # Create summary
        create_split_summary(splits_by_term, args.output_dir)
        
        logger.info("Split application completed successfully")
        return 0
        
    except Exception as e:
        logger.error(f"Error applying splits: {e}")
        import traceback
        logger.error(traceback.format_exc())
        return 1

if __name__ == '__main__':
    exit(main()) 